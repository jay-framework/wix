/**
 * Configuration Loader for Wix Data Plugin
 * 
 * Loads and validates wix-data.config.yaml from the project root.
 * If no config exists, generates a default config from the Wix Data API.
 */

import { WixClient } from '@wix/sdk';
import { collections } from '@wix/data';
import { WixDataConfig, CollectionConfig, ReferenceConfig } from './types';

// Configuration file name
const CONFIG_FILE_NAME = 'wix-data.config.yaml';

/**
 * Load the wix-data configuration from the project.
 * 
 * Looks for wix-data.config.yaml in the project root.
 * If not found, generates a default configuration from the Wix Data API.
 * 
 * @param wixClient - Optional Wix client for fetching collections when no config exists
 */
export async function loadConfig(wixClient?: WixClient): Promise<WixDataConfig> {
    console.log(`[wix-data] Looking for ${CONFIG_FILE_NAME}...`);
    
    // TODO: Implement actual file loading
    // For now, try to generate default config from Wix API if client is provided
    
    // In a real implementation:
    // 1. Find project root
    // 2. Try to load and parse YAML file
    // 3. If file exists, validate and return
    // 4. If file doesn't exist, generate default config
    
    // For now, always generate default config if we have a client
    if (wixClient) {
        console.log(`[wix-data] No config found, generating default from Wix Data API...`);
        return generateDefaultConfig(wixClient);
    }
    
    // No client, return empty config
    return { collections: [] };
}

/**
 * Generate a default configuration by fetching all collections from Wix Data API.
 * 
 * The generated config:
 * - Lists all collections with their references
 * - Sets empty components (no contracts generated by default)
 * - Uses '_id' as default slug field
 * - Uses collection ID as path prefix
 */
async function generateDefaultConfig(wixClient: WixClient): Promise<WixDataConfig> {
    const collectionsClient = wixClient.use(collections) as unknown as typeof collections;
    
    try {
        // Fetch all collections
        const result = await collectionsClient.listDataCollections({});
        const dataCollections = result.collections || [];
        
        console.log(`[wix-data] Found ${dataCollections.length} collections`);
        
        // Map each collection to a config entry
        const collectionConfigs: CollectionConfig[] = dataCollections
            .filter(c => c._id && !c._id.startsWith('_')) // Skip system collections
            .map(collection => {
                const collectionId = collection._id!;
                
                // Find reference fields
                const references: ReferenceConfig[] = (collection.fields || [])
                    .filter(f => f.type === 'REFERENCE' || f.type === 'MULTI_REFERENCE')
                    .map(f => ({
                        fieldName: f.key || '',
                        mode: 'link' as const // Default to link mode
                    }));
                
                // Find a suitable slug field (prefer 'slug', then 'title', then '_id')
                const fields = collection.fields || [];
                const slugField = fields.find(f => f.key === 'slug')?.key
                    || fields.find(f => f.key === 'title')?.key
                    || '_id';
                
                const config: CollectionConfig = {
                    collectionId,
                    pathPrefix: `/${collectionId.toLowerCase().replace(/[^a-z0-9]+/g, '-')}`,
                    slugField,
                    components: {} // No components enabled by default
                };
                
                // Only add references if there are any
                if (references.length > 0) {
                    config.references = references;
                }
                
                return config;
            });
        
        console.log(`[wix-data] Generated default config for ${collectionConfigs.length} collections`);
        
        return { collections: collectionConfigs };
        
    } catch (error) {
        console.error('[wix-data] Failed to fetch collections from Wix Data API:', error);
        return { collections: [] };
    }
}

/**
 * Validate a collection configuration
 */
export function validateCollectionConfig(config: CollectionConfig): string[] {
    const errors: string[] = [];
    
    if (!config.collectionId) {
        errors.push('collectionId is required');
    }
    
    if (!config.pathPrefix) {
        errors.push('pathPrefix is required');
    } else if (!config.pathPrefix.startsWith('/')) {
        errors.push('pathPrefix must start with /');
    }
    
    if (!config.slugField) {
        errors.push('slugField is required');
    }
    
    if (!config.components) {
        errors.push('components configuration is required');
    }
    
    // Validate category config if present
    if (config.category) {
        if (!config.category.referenceField) {
            errors.push('category.referenceField is required when category is configured');
        }
        if (!config.category.categorySlugField) {
            errors.push('category.categorySlugField is required when category is configured');
        }
    }
    
    return errors;
}

/**
 * Validate the entire configuration
 */
export function validateConfig(config: WixDataConfig): string[] {
    const errors: string[] = [];
    
    if (!config.collections || config.collections.length === 0) {
        errors.push('At least one collection must be configured');
        return errors;
    }
    
    // Check for duplicate collection IDs
    const seenIds = new Set<string>();
    config.collections.forEach(collection => {
        if (seenIds.has(collection.collectionId)) {
            errors.push(`Duplicate collectionId: ${collection.collectionId}`);
        }
        seenIds.add(collection.collectionId);
        
        // Validate each collection
        const collectionErrors = validateCollectionConfig(collection);
        errors.push(...collectionErrors.map(e => `${collection.collectionId}: ${e}`));
    });
    
    // Check for duplicate path prefixes
    const seenPaths = new Set<string>();
    config.collections.forEach(collection => {
        if (seenPaths.has(collection.pathPrefix)) {
            errors.push(`Duplicate pathPrefix: ${collection.pathPrefix}`);
        }
        seenPaths.add(collection.pathPrefix);
    });
    
    return errors;
}
